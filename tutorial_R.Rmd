---
title: "Introduction to R"
output: html_notebook
---

# About R

R is an object-oriented programming language. It is an integrated programming language where you can do data storage, data wrangling (modification), data analysis, statistical modeling, statistical tests, machine learning, and visualization.

You can even build a website, write a report or even a blog, and even build an app in R. Personally I enjoy doing everything in R. It was hard to start in the beginning because it was like learning a completely different language. But the basics were all I need to get started.

It is indeed impossible to master everything in R, but you can start off with the basics and keep learning with new methods and approaches while working with various data sets.

As R is also a multi-platform programming language, you can have access to many libraries that can help your analysis pipeline. The default library in R is **base package**, you don't need to download and install it before using it. Other libraries, **open-source packages**, are available for downloads. You have to download, install, and load them before using.

# Getting started

Download R and RStudio to your local computer.

So, R is essentially translating high-level language to machine codes. High-level language is a full sentence that you speak in everyday lives. In R, you have to simplify this language to pseudo-code (syntax, arguments) so R will understand. R then interprets the pseudo-code to machine code. Only then the machine can understand your request.

R is the console or the machine that interprets the pseudo-code you type to machine code. It then executes the pseudo-code.

RStudio is an Integrated Development Environment (IDE) or simply an interface to make coding easier. It can show you the objects you create in the Environment tab on the upper right panel. You can see the file directory you are on the Files tab in the bottom right panel. There are also sections for packages and help.

## Create a new script

In your RStudio, go to paperwhite button under File section on the task bar. Click it and click "R Script"

![](C:/Users/firza/AppData/Local/RStudio/tmp/paste-005C7B50.png)

It will take you to a new work script. Here you can type codes. When you've finished and you want to save it, go to File --\> Save as...

I recommend you to save the file in all lower letters and without space. You can separate words using underscore sign ( \_ ).

## Change preferences/theme

If you want to change the preferences or the theme of your RStudio, you can go to Tools --\> Global Options --\> Appearance. You can play with the options there, then click Apply.

## Objects in R

You can create an object in R and assign a value in it. It is useful for analysis as you don't have to keep typing the same code over and over again. You can access the values stored in this object every time you're calling the object.

To run a code, press ctrl+enter

```{r objects}
# We want to do calculation
10+2

# This gives you the result. But if you want to access it again, you can't because you don't know how to call them

# This is where object is useful. You assign a name to the value and every time you want to access this value, you can just type the name

addition = 10 + 2

# Call the object
addition

# Integrating it with other calculation
substraction = addition - 5

substraction
```

## Data types in R

-   Integer: numbers such as 1, 2, 3, ... except decimals

```{r integer}
class(1) # class is a function to check the type of an object
```

-   Numeric: numbers including decimals

```{r numeric}
class(1.5)
```

-   Character: a type for words, letters, sentences. You should always put quotation marks in between a sentence, a word, or a letter to tell R that these are character data types. Otherwise, you will run to an error.

```{r strings}
class("hello, how are you?")
```

-   Data frame: a data table that contains observations in rows and variables in column. Example: data tables from Excel spreadsheet. I will explain about data frame in the next section.

-   Vector: an object that stores multiple values of the same data type. If you want to make a numeric vector, all the values inside it should be numeric. If you want to make a vector with another data type, you have to make sure that the values you input are of the same data type.

You can create a vector by manually entering the values. The values should be in the same data type. In this case, they values are in numeric data type.

```{r create vector 1}
create_vector = c(1, 2, 3, 4, 5)

create_vector

class(create_vector)
```

You can create a vector by passing a range of values.

```{r vector with range}
vector_2 = 1:10

vector_2
```

You can also ask R to generate random values to fill your vector. We will be using function sample() after the vector object we create.

-   sample(): the function to generate random numbers

-   argument 1:100 : the argument you give to R to say that you need random numbers within the range 1:100 . You can put any range in this argument

-   argument 15 (after the range): how many random numbers you need from the random number generator. In this case, I ask R to give me 15 random numbers within the range 1:100. You can put any number in this argument, it depends on your need.

-   Replace: TRUE, if you want the random numbers to come multiple times. FALSE, if you need the random numbers to come only once.

```{r random values}
vector_3 = sample(1:100, 15, replace = TRUE)

vector_3
```

However, if you use sample() and you run it a couple times, you will get different values for vector_3. This is not reproducible if you want to use vector_3 in your analysis. To solve this, we can call the function set.seed() before creating our vector with random numbers. You can try running these code multiple times and you will still get the same values.

```{r random seed}
set.seed(0)
vector_4 = sample(1:100, 20, replace = TRUE)

vector_4
```

## Accessing the values within vector

Vectors, lists, arrays, and data frames are indexed objects. This means that they store several values and assign to each of them a numerical index that indicates their position within the object. We can access the information stored in each of the positions by using object_name[position].

To access the second element (index = 2) in vector_4, we should code:

```{r index 2}
# See the inside of vector_4
vector_4

# Accessing the second element of vector_4
vector_4[2]
```

We can also access the elements in vector_4 by giving the range of indexes that we want to access. This is called **vector slicing**. For example, if we want to access the elements from range 2 to 5 in vector_4, we should code:

```{r vector slicing}
vector_4[c(2:5)]
```

We can also check the length of vector_4 using function length()

```{r length}
length(vector_4)
```

It basically shows you how many elements (or values) are stored in vector_4. Note that you can only access the elements within the length of vector_4. In other words, you can only access the elements from range 1 to 20. If you want to access an element in index 21 from vector_4, it is not possible because it is beyond the length of vector_4.

It applies to any vector you make with various length.

You can also add new values or elements to your vector. For example, if we want to add value 70 to index 21 in vector_4:

```{r add index21}
# Checking vector_4
vector_4

# Add a new value to vector_4 and store it to vector_5
vector_5 = vector_4 # copying everything in vector_4 to vector_5

# Check vector_5
vector_5

# Add a new value to vector_5
vector_5[21] = 70

vector_5

# How is it different from vector_4
vector_4
```

In this example I created a new vector (vector_5) by copying everything in vector_4. This is to keep the original elements in vector_4 so I can show you how vector addition looks like. I made the changes of vector_4 in vector_5.

I added a new value (70) to vector_5 and when I compared vector_5 and vector_4, there is now 70 in vector_5 that I can't find in vector_4.

## Mathematical operation in vector

You can do mathematical operation for the elements of a vector.

-   Multiplication

    Example: if we want to double every elements in vector_5

```{r double}
double_elm = vector_5*2

# Before multiplication
vector_5

# After multiplication
double_elm
```

-   Division

    Example: if we want to divide every elements in vector_5 by 5

```{r division}
division_5 = vector_5/5

# Before division
vector_5

# After division
division_5
```

-   Addition

    Example: if we want to add every elements in vector_5 with 4

```{r addition}
addition_4 = vector_5 + 4

# Before addition
vector_5

# After addition
addition_4
```

-   Subtraction

    Example: if you want to subtract every elements in vector_5 by 4

```{r subtraction}
subs_4 = vector_5 - 4

# Before subtraction
vector_5

# After subtraction
subs_4
```

Check this YouTube video for more arithmetic operations in vector:

[Create and Work with Vectors and Matrices in R \| R Tutorial 1.4 \| MarinStatslectures - YouTube](https://www.youtube.com/watch?v=2TcPAZOyV0U)

# Working with a data frame

## Setting your working directory

Important: before you do any analysis in R, you should set your working directory i.e. the folder where your data is saved. Not only that this is the folder where you save the data you need for analysis, but also this is the folder where your analysis results will be stored.

The path to the directory is specified in text format, so you type it **"in quotation marks"**.

The way to do it is:

```{r setwd}
setwd(dir = "C:/Users/firza/Documents/Course_Tree_improvement")
```

In dir =, you pass the folder where your file resides in your laptop.

## Checking the directory you are currently resided

Double check if you are in the right working directory. Just pass this function and R will return the location of the folder you are resided right now.

```{r getwd}
getwd()
```

## Importing a data frame

To import a data frame, you should use read.table() function in R. R support any kinds of data set, from flat files to raster files. This time you should be familiar on how to import a data frame from flat file formats, such as .csv or .txt. The read.table() function supports .csv and .txt files.

Arguments within the read.table function that you usually need to give to R:

-   It is advisable to save the data as an object.

```{=html}
<!-- -->
```
-   file = the name of the file you want (it should reside in the folder that you set as your working directory). The file name is in text format, so you should type it in with quotation marks ( " " ).

-   header = TRUE if the first row of your data is the name of your variables

-   sep = separation between columns. If you're using .txt file like I do here, the separation between columns is made by a tab or "\\t". If you're using .csv file, the separation is made by a comma or " , ".

-   dec = the sign for decimal used in your file. Sometimes, different language uses different signs to make a decimal. In English keyboard, decimals are marked by a point or " . ", while in French keyboard, decimals are marked by a comma or " , " such as what we see in our data frame.

Fun YouTubers to follow if you want to learn R programming:

[Import Data, Copy Data from Excel to R CSV & TXT Files \| R Tutorial 1.5 \| MarinStatsLectures - YouTube](https://www.youtube.com/watch?v=qPk0YEKhqB8)

[R Programming for Beginners \| Complete Tutorial \| R & RStudio - YouTube](https://www.youtube.com/watch?v=BvKETZ6kr9Q)

```{r data frame}
# Import a sample data frame
rust_data = read.table(file = "B4est_test1_LectureJ13_J14_commented.txt",
                       header = TRUE,
                       sep = "\t",
                       dec = ",",
                       quote = "\"")

# See the documentation of read.table
help("read.table")

class(rust_data)
```

You can also use:

-   read.csv (for csv file with a header and decimal is marked with a point or " . ")

-   read.csv2 (for csv file with a header and decimal is marked with a comma or " , ")

-   read.delim (for txt file with a header and decimal is marked with a point or " . ")

-   read.delim2 (for txt file with a header and decimal is marked with a comma or " , ")

Data frame is essentially an array made of x rows and y columns. In a data frame, you will have observations in rows and variables in columns. You can access a certain column (i.e. variable) with the help of "\$" sign as given in the example below.

```{r dollar sign}
# accessing the genotype column
vector_genotype = rust_data$Genotype

class(vector_genotype)
```

When you check the class of vector_genotype, it returns 'character' because all the values are in character data type.

You can see the whole data by clicking the spreadsheet icon at the right side of your data frame object. You can find this in the "Environment" tab on the upper right panel.

![](C:/Users/firza/AppData/Local/RStudio/tmp/paste-C5AB985A.png)

## Head function

You can also check the first few rows of the data by using head() function. By default, it will show the first 6 rows of the data.

```{r head}
head(rust_data)
```

But, you can also specify how many rows you want R to return by passing the number in the n argument of the head() function

```{r n argument}
head(rust_data, n = 10)
```

## Tail function

You can also check the last few rows of your data using tail() function. You can specify the number of rows you want R to return in the n argument of the tail() function.

```{r tail n}
tail(rust_data, n = 10)
```

## To check the dimension of the data

You can check how many observations and variables are contained in the data frame using dim() function.

```{r dim}
dim(rust_data)
```

dim will return the number of rows (or observation) in the left side of the result and the number of variables (or columns) in the right side. The data frame we are using contains 2520 observations and 15 variables.

## To check the names of the variables

It is sometimes important to know the names of the variables. You can use the information to select, rename, or remove variables. To check the names of the variables, you can use colnames() function followed by the name of the data frame.

```{r colnames}
colnames(rust_data)
```

It returns a list of variable names. The list contains indexed names, meaning that each variable has its own position in the list. This indexes corresponds to the position of the variable in the data frame. For example, if you want to access variable "Laten_24.02.15_gp" by its index, you can do the following

```{r access vars}
vector_latent = rust_data[ , 6]

head(vector_latent)
```

Note that I leave a space in the beginning of the square brackets. This is because when you are accessing the index of an array (remember that a data frame is an array), you pass the index for the row in the left side of the bracket and the index of the column in the right side. So when you pass the following code, you are accessing the data in row 4 and in column 6.

```{r index array}
row_4_data = rust_data[4, 6]

row_4_data
```

Because you are accessing for the data in a specific position, you will get a single value. If you look back to the data frame, this value is essentially the latent period (Laten_24.02.15_gp) for genotype 6-A18 in block 1.

You can also access a certain row using the following code:

```{r access row}
row_4_vars = rust_data[4, ]

row_4_vars
```

The code returns all the information that entails the genotype 6-A18 in block 1. This is more intuitive than just getting the single value like before. If you only want to know the latent period for genotype 6-A18, you can do the following instead:

```{r only latent}
rust_data$Laten_24.02.15_gp[4]
```

How I did it is I first select the variable using the dollar sign "\$" and get only the row number 4

It is always best to access variables using their name with the help of the "\$" sign. Also, if you are accessing a big file, always keep them in an object to allow easy access.

```{r vars dollar}
vector_lat = rust_data$Laten_24.02.15_gp

head(vector_lat)
```

## Column slicing

Sometimes, it is also useful to use indexes to select columns or rows. For example, we can select the variables latent period (Laten_24.02.15_gp), spore number on the leaves (NbSS_24.02.15_gp), spore number under the water (NbSO_24.02.15_gp), black points (NbPtN_24.02.15_gp) and spore size (Taill_05.08.20_gp) in two ways:

-   Selecting based on the index. The indexes for the variables are from index 6 to 11. So we can do the following (it's called column slicing)

```{r col slicing}
col_slice_data = rust_data[, c(6:11)]

head(col_slice_data)
```

-   Selecting using column names using subset function. You can pass on the names of the columns into the argument select in the function.

```{r col subset}
col_subset_data = subset(rust_data, select = c("Laten_24.02.15_gp",
                                               "NbSS_24.02.15_gp",
                                               "NbSO_24.02.15_gp", 
                                               "NbPtN_24.02.15_gp"))

head(col_subset_data)
```

Maybe you want to know the names of the genotypes. You can add the genotype names into the subset function.

```{r with genot}
col_subset = subset(rust_data, select = c("Genotype",
                                          "Laten_24.02.15_gp",
                                          "NbSS_24.02.15_gp",
                                          "NbSO_24.02.15_gp",
                                          "NbPtN_24.02.15_gp"))

col_subset
```

## Checking data types

Remember that we're talking about data types such as string, numeric and integer in the above sections. We can check the data types of each variable from a data frame. It is important to check if the variables are in the correct types to avoid misleading analysis and errors.

For example, we do not want that a variable with numerical data type is being recorded as character type by R. When we do mathematical analysis with this variable, R will return an error because essentially you can't do mathematical analysis in character type.

One way to do it is by using class() function followed by the variable (remember to use the dollar sign to access a variable within a data frame) like I've showed you before.

```{r class}
class(rust_data$Genotype)

class(rust_data$Laten_24.02.15_gp)
```

Another way is by using str() function followed by the name of the data frame. This function will return the data types of all the variables contained in a data frame. Using this function, you can evaluate the data types of the variables at once. It saves you time as you don't have to check the variables one by one.

```{r str fun}
str(rust_data)
```

The str() function tells you:

-   The dimension of the data frame (obs and variables at the first line) --\> same results as when you're using dim()

-   The names of the variables --\> same results as when you're using colnames()

-   The types of the variables --\> same results as when you're using class() to each variable one by one

-   The data of the first few lines of the data frame --\> same results as when you're using head()

So, using str(), you can check all the stuff we learned at once. It is more efficient than calling the function (i.e. dim, colnames, etc.) one by one.

# Final words

## Other options

R is great, but there are other options such as Python. R and Python are similar and they have the biggest community, open source database, and public packages/libraries. I recommend you to learn R or Python because:

-   You can always find free or cheap online courses dedicated to R or Python

-   Most data scientists are either using R or Python. Your teachers or colleagues or IT friends are most likely have experiences in R or Python. You can ask for a help from them whenever you encounter problems.

-   You can find the answers to almost all your confusion just by typing your problems in Google. There are big support communities that use R or Python.

## Personal thoughts

Personally, I would recommend you to learn R or Python. Integrate them in your analysis pipeline. Once you get a good grasp with the basics, learn new methods and challenge yourself to use the new methods in your next analysis. There are always spaces to improve and optimize your code.

I save a lot of time by mastering R. I initially used R only to analyze data. Then I explored other features, such as R markdown which allows me to code and write report at the same time. I could also automate some analysis, such as opening file and do a bit of cleaning (using loop and function). It saves a lot of my time. I can automatically cite paper and put them directly to my References section. R just made my life more efficient.

Another positive thing about learning R or Python is that you create more opportunities for yourself. There are many companies looking for Data Analysts or Data Scientists. The salary is quite higher than average, for example the median gross annual salary for a Junior Data Analyst is 50k Euros/year in Paris and Berlin. In the US, you can even get up to 70k Euros/year. The growth of the position is high, there is a rising demand in many industries (24% in the next few years). You can move forward to senior positions real fast, like 1 - 2 years and you will be in intermediate level, another 2 years to get to senior level.

## Vector slicing

## Insert a new value to a vector

```{r}
length(vec_3)

vec_3[10] = 6

vec_3
```

## Logical operators

```{r}
length(vec_2)

vec_2 > 5
```

## Data frame: Start off with mpg data.

-   Install ggplot

-   Load ggplot

-   Load mpg data

-   Today I am going to the supermarket --\> pseudo code --\> R --\> machine code

```{r}
cars = mpg
```

View cars, variables and rows

## Setting working directory

```{r}
setwd("~/Course_Tree_improvement")
```

Or from the files tab --\> go to the directory you intend --\> more --\> set as working directory

## Load files

```{r}
rust_test1 = read.delim2("B4est_test1_LectureJ13_J14_commented.txt", na = "NA")

help("read.csv")
```

runnig code = ctrl + enter

## Checking the first five rows in the dataset

```{r}
head(rust_test1, n = 5)
```

Or you can click the spreadsheet next to the object

## Checking the names of the variables

```{r}
names(rust_test1)
```

## Data types

Integer = number (1,2,3,...)

Numeric = also number, including decimals

Factor = categorical values

Strings = characters

Vector = a list of values of the same type

Data frame = table composed of vectors

```{r}
# Checking the data types of each variable
str(rust_test1)
```

Vector

```{r}
# Selecting a variable
# It is essentially called a vector
latent = rust_test1$Laten_24.02.15_gp

# The argument is basically to select a variable
```

Sometimes it's useful to convert a variable from one data type to another. If we want to convert block from character to factor. Grouping them into 5 levels

```{r}
rust_test1$Block = as.factor(rust_test1$Block)

str(rust_test1)
```

## Selecting variables based on their index

```{r}
names(rust_test1)
```

```{r}
genotype = rust_test1[,3]
```

# Selecting rows based on their index

```{r}
latent_ind_1 = rust_test1[1,6]
```

## Rename

```{r}
names(test1_loop)[1:3] = c("Latent Period", "Uredinia Number", "Uredinia Size")
```

## Subset

```{r}

test1_09AX27 = test1_selec[which(test1_selec$Strain == "09AX27"),]
test1_93JE3 = test1_selec[which(test1_selec$Strain == "93JE3"),]
test1_P72 = test1_selec[which(test1_selec$Strain == "P72"),]

```

## Merge columns

```{r}
latent = rust_test1$Laten_24.02.15_gp

genotype = rust_test1$Genotype

new_rust = data.frame(cbind(genotype, latent))


```

# Join different datasets

```{r}
df_dummy = data.frame(genotype = rust_test1$Genotype,
                      dummy_variable = sample(1:100, 1))

to_merge = data.frame(genotype = rust_test1$Genotype,
                      spore_number = sample(1:1000, 1))

new_join = merge(to_merge, df_dummy, by = "genotype") 
```

## Simple statistics

Summary Mean, sd, max, min

## Visualization

```{r}
library(ggplot2)
str(mpg)

plot(mpg$displ, mpg$hwy)

plot(rust_test1$Laten_24.02.15_gp, rust_test1$NbSS_24.02.15_gp)

hist(rust_test1$Laten_24.02.15_gp)
```
